#!/usr/bin/env python3

#MIT License
#Copyright (C) 2019 plasticuproject.pm.me
#https://github.com/plasticuproject/rest
#Thanks to mikesZ81 for concept and inital logic


from termcolor import cprint
import subprocess
import warnings
import argparse
import pysftp
import os
import re


platforms = ['linux','linux_crisv32','linux_mips','linux_ppc','linux_sparc','lin_x86','lin_x86-64','multiple']
badpacks = ('centos','debian','ubuntu','redhat','addon','agent','apps','base','bin','bsd','cache','check','client','command',
            'common','configuration','control','core','cron','data','database','dev','editor','events','extras','family','file',
            'files','form','ftp','generic','gnu','headers','http','info','installation','kernel','legacy','linux','load','manager',
            'message','module','monitor','net','network','one','open','patch','path','plugin','plugins','release','router','secure',
            'security','server','ssl','software','standard','support','system','team','text','the','theme','time','toolkit','tools',
            'unix','update','user','utility','viewer','web','wifi','windows','wireless')
hostname = ''
user = ''
port_num = ''
secret = ''
key_file = ''
logo = ('''

                     _____________________ ____________________
                     \______   \_   _____//   _____/\__    ___/
                      |       _/|    __)_ \_____  \   |    |   
                      |    |   \|        \/        \  |    |   
                      |____|_  /_______  /_______  /  |____|   
                             \/        \/        \/            
''')


def banner():

    #print banner information
    cprint(logo, 'blue', attrs=['bold'],)
    cprint('\t\t\t      Remote Exploit Scan Tool\n\n', 'red', attrs=['bold'])
    cprint('A tool to remotely scan Linux system packages via SSH.\n\n', attrs=['bold'])
    cprint('To use:', 'red')
    print('Once SSH credentials have been obtained use this tool to remotely scan system')
    print('packages for known exploits in Exploit-DB.\n')
    print('example with user and password   | ./rest 192.168.1.100 vera -p eatadick6969 -n 666')
    print('example with RSA and password    | ./rest 192.168.1.101 jeff -p my_name_a -k ~/.ssh/id_rsa')
    print('example with RSA and no password | ./rest 192.168.1.102 bigwillystyle -k ~/.ssh/id_rsa\n\n')


def get_args():

    # start script and parse arguments
    global hostname, user, port_num, secret, key_file
    parser = argparse.ArgumentParser(description=banner())
    parser.add_argument('host', type=str, metavar='hostname', help='hostname or IP address of remote machine')
    parser.add_argument('user', type=str, metavar='username', help='username used to login to host.')
    parser.add_argument('-n', type=int, metavar='port_number', nargs='?', help='port number (default is 22).', default=22)
    parser.add_argument('-p', type=str, metavar='password', help='password for user.')
    parser.add_argument('-k', type=str, metavar='key_file', help='location of RSA or DSA Key file')
    args = parser.parse_args()
    hostname = args.host
    user = args.user
    port_num = args.n
    secret = args.p
    key_file = args.k


def password_connect():

    # connects to remote machine via ssh with user/pass combo and downloads list of installed packages
    cprint('[*]Connecting to {} as {}...[*]'.format(hostname, user), 'green')
    cnopts = pysftp.CnOpts()
    cnopts.hostkeys = None
    with pysftp.Connection(hostname, username=user, password=secret, port=port_num, cnopts=cnopts) as sftp:
        sftp.execute('dpkg -l > packages.txt')
        sftp.get('packages.txt')
        sftp.execute('rm packages.txt')
        format_dpkg_file()
        if os.stat('packages.txt').st_size == 0:
            sftp.execute('rpm -qa > packages.txt')
            sftp.get('packages.txt')
            sftp.execute('rm packages.txt')
            format_rpm_file()
        cprint('[*]Downloading package list...[*]', 'green')


def key_file_connect():

    # connects to remote machine via ssh with private keyfile and downloads list of instaled packages
    cnopts = pysftp.CnOpts()
    cnopts.hostkeys = None
    os.system('eval "$(ssh-agent -s)" && ssh-add {}'.format(key_file))
    with pysftp.Connection(hostname, username=user, port=port_num, private_key_pass=secret, private_key=key_file, cnopts=cnopts) as sftp:
         sftp.execute('dpkg -l > packages.txt')
         sftp.get('packages.txt')
         sftp.execute('rm packages.txt')
         format_dpkg_file()
         if os.stat('packages.txt').st_size == 0:
             sftp.execute('rpm -qa > packages.txt')
             sftp.get('packages.txt')
             sftp.execute('rm packages.txt')
             format_rpm_file()
         cprint(['[*]Downloading package list...[*]'], 'green')


def format_dpkg_file():

    # format packages.txt file for use in searchsploit
    packages = []
    first_field = 1
    with open('packages.txt', 'r') as pFile:
        for line in pFile:
            if line[:2] == 'ii':
                fields = line.split()
                if len(fields) < 2 + first_field:
                    continue
                search = fields[first_field].find(':')
                if search != -1:
                    soft_name = clean(fields[first_field][:search])
                else:
                    soft_name = clean(fields[first_field])
                search = re.search(r"-|\+|~", fields[first_field + 1])
                if search:
                    soft_version = fields[first_field + 1][:search.span()[0]]
                else:
                    soft_version = fields[first_field + 1]
                search = soft_version.find(':')
                if search != -1:
                    soft_version = soft_version[search + 1:]
                soft_version = cleanVersionString(soft_version)
                if not soft_name or not soft_version:
                    continue
                if '-' in soft_name:
                    for sub_package in soft_name.split('-'):
                        if len(sub_package)>2 and '.' not in sub_package and sub_package not in badpacks:
                            name_version = sub_package +' ' + soft_version
                else:
                    if soft_name not in badpacks:
                        name_version = soft_name + ' ' + soft_version
                packages.append(name_version)
    pFile.close()
    os.system('rm packages.txt')
    with open('packages.txt', 'a') as pFile:
        for line in packages:
            pFile.write(line + '\n')
    pFile.close()


def format_rpm_file():

    #format packages.txt file for use in searchsploit
    packages = []
    with open('packages.txt', 'r') as pFile:
        for line in pFile:
            fields = '.'.join(line.split('.')[:-2]).split('-')
            if len(fields) < 2:
                continue
            soft_name = clean('-'.join(fields[:-2]))
            soft_version = cleanVersionString(fields[-2])
            if not soft_name or not soft_version:
                continue
            if '-' in soft_name:
                for sub_package in soft_name.split('-'):
                    if len(sub_package)> 2 and '.' not in sub_package and sub_package not in badpacks:
                        name_version = sub_package + ' ' + soft_version
            else:
                if soft_name not in badpacks:
                    name_version = soft_name + ' ' + soft_version
            packages.append(name_version)
    pFile.close()
    os.system('rm packages.txt')
    with open('packages.txt', 'a') as pFIle:
        for line in packages:
            pFIle.write(line + '\n')
    pFile.close()


def clean(soft_name):

    # clean package name from common strings
    for badword in badpacks:
        soft_name = re.sub(r'-' + badword, '', soft_name)
    return soft_name


def cleanVersionString(version_string):

    # eliminate invalid characters and last dot from version string
    search = re.search(r'[^0-9.]', version_string)
    if search: result = version_string[:search.span()[0]]
    else: result = version_string
    if len(result) > 0 and result[-1] == '.': result = result[:-1]
    return result


def searchsploit():

    # checks every package in pacakages.txt against searchsploit database, saves them to file and prints to screen
    try:
        cprint('[*]Checking packages against Searchsploit Database...[*]', 'green')
        cprint('[*]Please be patient, this may take a few minutes...[*]', 'yellow')
        os.system('while read line; do searchsploit "$line" linux | grep -v "No Result"; done < packages.txt > exploits.txt')
        subprocess.call(['cat', 'exploits.txt'])
        cprint('[*]Writing results to exploits.txt...[*]', 'green')
        cprint('[*]Done[*]\n', 'green')
    except Exception as e:
        print(e)
        quit()


def clean_old():
    try:
        os.system('rm exploits.txt')
    except:
        pass
    try:
        os.system('rm packages.txt')
    except:
        pass


def main():

    # main program
    warnings.filterwarnings('ignore')
    try:
        clean_old()
        get_args()
        try:
            password_connect()
        except Exception as e:
            print(e)
            try:
                key_file_connect()
            except Exception as e:
                print(e)
                cprint('[*]Could not connect to {}.[*]'.format(hostname), 'red')
                quit()
        searchsploit()
    except KeyboardInterrupt:
        quit()


if __name__ == '__main__':
    main()

